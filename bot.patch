 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/memory/player_bot_states/.gitkeep b/memory/player_bot_states/.gitkeep
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
--- /dev/null
+++ b/memory/player_bot_states/.gitkeep

diff --git a/scripts/bot_base.lua b/scripts/bot_base.lua
index 8258266af45277c7ea06e26b14e7f8d20b7f65ad..b376de89989bd2d430856041b9cf55d3375bff93 100644
--- a/scripts/bot_base.lua
+++ b/scripts/bot_base.lua
@@ -1,29 +1,30 @@
 -- scripts/bot_base.lua
 local Direction = require("scripts/libs/direction")
 local BotMovementHelper = require("scripts/bot_movement_helper") -- Assuming BotMovementHelper is loaded successfully
-local SceneRunner = require("scripts/scene_runner")
+local SceneRunner = require("scripts/scene_runner")
+local BotStateManager = require("scripts/bot_state_manager")
 
 local BotBase = {}
 BotBase.__index = BotBase -- For metatable-based object orientation (optional but good practice)
 
 local all_active_bots = {} -- Stores all active bot instances by their bot_id
 
 -- Parses an action string into a command table. (Same as before)
 local function parse_action_string(action_str)
     local move_cmd, move_dir, move_dist = action_str:match("^(move)%s+([%a]+)%s+([%d%.]+)$")
     if move_cmd then return { command = "move", direction_str = string.lower(move_dir), distance = tonumber(move_dist) } end
     local wait_cmd, wait_time = action_str:match("^(wait)%s+([%d%.]+)$")
     if wait_cmd then return { command = "wait", time = tonumber(wait_time) } end
     if string.lower(action_str) == "loop" then return { command = "loop" } end
     print("BOT_BASE WARNING: Could not parse action string: '" .. action_str .. "'")
     return nil
 end
 
 --- Creates a new bot instance.
 -- @param config table The specific configuration for this bot (ACTION_LIST, BOT_SETUP_CONFIG contents)
 function BotBase.new(config)
     local instance = setmetatable({}, BotBase)
 
     instance.config = config -- Store the provided config (includes dialogue, action list, etc.)
     
     local initial_pos_obj = Net.get_object_by_name(instance.config.area_id, instance.config.spawn_object_name)
@@ -91,80 +92,83 @@ function BotBase:process_next_action()
 
     self.current_action_data = parsed_action
 
     if parsed_action.command == "move" then
         local destination = BotMovementHelper.calculate_action_destination(self.bot_object.current_tile_pos, parsed_action.direction_str, parsed_action.distance)
         if destination then
             self.bot_object.walk_target = destination; self.bot_object.walking = true; self.is_processing_action = true
         else
             print("BOT_BASE (" .. self.config.bot_name .. "): Move target for '" .. action_string .. "' is invalid/blocked. Skipping.")
             self.is_processing_action = false; self.current_action_data = nil
         end
         self.current_action_index = self.current_action_index + 1
     elseif parsed_action.command == "wait" then
         self.current_action_data.time_remaining = parsed_action.time; self.is_processing_action = true
         self.current_action_index = self.current_action_index + 1
     elseif parsed_action.command == "loop" then
         self.current_action_index = 1; self.is_processing_action = false; self.current_action_data = nil
     else
         self.current_action_index = self.current_action_index + 1; self.is_processing_action = false; self.current_action_data = nil
     end
 end
 
 --- Method to handle actor interaction for a bot instance.
 function BotBase:handle_interaction(event_player_id)
     if self.interacting_player_id ~= nil then
-        if self.interacting_player_id == event_player_id then return else
+        if self.interacting_player_id == event_player_id then return else
             Net.message_player(event_player_id, self.config.dialogue_busy, self.bot_object.mug_texture_path, self.bot_object.mug_animation_path)
             return
         end
     end
 
     self.interacting_player_id = event_player_id
     self.action_list_paused = true
 
-    local state_table = self.player_states[event_player_id]
-    if not state_table then
-        state_table = { state = self.config.initial_state }
-        self.player_states[event_player_id] = state_table
-    end
+    Async.promisify(coroutine.create(function()
+        local all_states = Async.await(BotStateManager.load_states(event_player_id))
+        local state_table = all_states[self.config.bot_name]
+
+        if not state_table then
+            state_table = { state = self.config.initial_state }
+            all_states[self.config.bot_name] = state_table
+        end
+
+        self.player_states[event_player_id] = state_table
+
+        local scene_key = state_table.state or self.config.initial_state
+        local scene = nil
+        if self.config.SCENES then scene = self.config.SCENES[scene_key] end
+
+        if scene then
+            Async.await(SceneRunner.run(self, event_player_id, scene))
+            all_states[self.config.bot_name] = self.player_states[event_player_id]
+            Async.await(BotStateManager.save_states(event_player_id, all_states))
+        end
 
-    local scene_key = state_table.state or self.config.initial_state
-    local scene = nil
-    if self.config.SCENES then scene = self.config.SCENES[scene_key] end
-
-    if not scene then
-        self.interacting_player_id = nil
-        self.action_list_paused = false
-        return
-    end
-
-    SceneRunner.run(self, event_player_id, scene)
-    .and_then(function()
-        self.interacting_player_id = nil
-        self.action_list_paused = false
-    end)
+        self.interacting_player_id = nil
+        self.action_list_paused = false
+    end))
 end
 
 --- Method to update a bot instance on tick.
 function BotBase:update_tick(dt)
     if self.action_list_paused then return end
 
     if self.is_processing_action then
         if self.bot_object.walking then
             BotMovementHelper.update_movement_on_tick(self.bot_object, dt, Net)
             if not self.bot_object.walking then self.is_processing_action = false; self.current_action_data = nil end
         elseif self.current_action_data and self.current_action_data.command == "wait" then
             self.current_action_data.time_remaining = self.current_action_data.time_remaining - dt
             if self.current_action_data.time_remaining <= 0 then self.is_processing_action = false; self.current_action_data = nil end
         end
     end
 
     if not self.is_processing_action then
         self:process_next_action()
     end
 end
 
 
 -- Global Event Handlers (These will dispatch to the correct bot instance)
 Net:on("actor_interaction", function(event)
     local bot_instance = all_active_bots[event.actor_id]
diff --git a/scripts/bot_state_manager.lua b/scripts/bot_state_manager.lua
new file mode 100644
index 0000000000000000000000000000000000000000..6fddca83bbac9c17dcaded0b79106ad589c01d53
--- /dev/null
+++ b/scripts/bot_state_manager.lua
@@ -0,0 +1,58 @@
+local BOT_STATE_FOLDER = "memory/player_bot_states/"
+
+local function url_encode(str)
+  return (str:gsub("[^%w%-_.]", function(c)
+    return string.format("%%%02X", string.byte(c))
+  end))
+end
+
+local function encode_table(tbl)
+  local lines = {"return {\n"}
+  for bot, state in pairs(tbl) do
+    table.insert(lines, string.format("  [%q] = {\n", bot))
+    for k, v in pairs(state) do
+      if type(v) == "string" then
+        table.insert(lines, string.format("    %s = %q,\n", k, v))
+      elseif type(v) == "number" or type(v) == "boolean" then
+        table.insert(lines, string.format("    %s = %s,\n", k, tostring(v)))
+      end
+    end
+    table.insert(lines, "  },\n")
+  end
+  table.insert(lines, "}\n")
+  return table.concat(lines)
+end
+
+local function decode_table(str)
+  local chunk = load(str)
+  if not chunk then return {} end
+  local ok, tbl = pcall(chunk)
+  if ok and type(tbl) == "table" then
+    return tbl
+  end
+  return {}
+end
+
+local BotStateManager = {}
+
+function BotStateManager.load_states(player_id)
+  local identity = Net.get_player_secret(player_id)
+  local path = BOT_STATE_FOLDER .. url_encode(identity) .. ".lua"
+  return Async.promisify(coroutine.create(function()
+    local data = Async.await(Async.read_file(path))
+    if data and #data > 0 then
+      return decode_table(data)
+    else
+      return {}
+    end
+  end))
+end
+
+function BotStateManager.save_states(player_id, tbl)
+  local identity = Net.get_player_secret(player_id)
+  local path = BOT_STATE_FOLDER .. url_encode(identity) .. ".lua"
+  local content = encode_table(tbl)
+  return Async.write_file(path, content)
+end
+
+return BotStateManager
 
EOF
)