 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/docs/ENEMY_MODDING.md b/docs/ENEMY_MODDING.md
index 4d01dd5c1c47527f5c8b5906761c457861cd020c..550fe0d1b59d346f1965fde9bffc510e8fcced63 100644
--- a/docs/ENEMY_MODDING.md
+++ b/docs/ENEMY_MODDING.md
@@ -81,25 +81,70 @@ Features include:
 - Automatic timers via a `duration` field and `next_state`/`on_complete`
   transitions.
 - Event hooks for `spawn`, `battle_start`, `hit`, `stun` and `delete`.
 - A scheduler available through `enemy:schedule(frames, callback)`.
 - Basic animation management when a state specifies `animation` and
   `playback`.
 
 Load the helper with `include("enemy_base.lua")` and initialise it:
 
 ```lua
 enemy_base.init(self, {
   states = states,
   start_state = "IDLE",
   on_delete = function(e)
     -- cleanup logic
   end
   ,on_hit = function(e, from_stun)
     -- react to damage
   end
 })
 ```
 
 States can then be described purely in data while custom behaviour is
 added through the callbacks.
 
+
+#### Event hooks
+
+Callbacks registered with `enemy:on(name, cb)` are stored per enemy instance and automatically tied to the engine's lifecycle hooks. The helper replaces the built-in `update_func`, `delete_func`, `on_spawn_func`, `battle_start_func` and `hit_func` so events fire whenever those functions run. Hooks are not tied to states, but to the creature as a whole. You can therefore listen for `hit` or `stun` even while in any state.
+
+```
+self:on("spawn", function(e)
+  -- executed once the enemy is placed on the field
+end)
+self:on("delete", function(e)
+  -- cleanup when removed
+end)
+```
+
+#### Spawning projectiles
+
+Projectiles are usually implemented as `Battle.Spell` objects. Create the spell, configure its hit properties and behaviour, then spawn it on the field:
+
+```lua
+local spell = Battle.Spell.new(self:get_team())
+spell:set_hit_props(HitProps.new(40, Hit.Impact | Hit.Flinch, Element.None,
+                                self:get_context(), Drag.None))
+spell.update_func = function(s)
+  s:get_current_tile():attack_entities(s)
+  local dest = s:get_tile(self:get_facing(), 1)
+  s:slide(dest, frames(4), frames(0), ActionOrder.Voluntary)
+end
+self:get_field():spawn(spell, self:get_tile(self:get_facing(), 1))
+```
+
+#### Creating obstacles
+
+Obstacles work similarly using `Battle.Obstacle.new`. They persist on the field until deleted. An obstacle can notify the enemy when it is destroyed via its `delete_func`:
+
+```lua
+local rock = Battle.Obstacle.new(self:get_team())
+rock:set_health(40)
+rock.delete_func = function(o)
+  -- obstacle disappeared, switch behaviour
+  self:set_state("IDLE")
+end
+self:get_field():spawn(rock, target_tile)
+```
+
+The enemy can also keep a reference to the spawned obstacle if it needs to check its state in later updates.
 
EOF
)