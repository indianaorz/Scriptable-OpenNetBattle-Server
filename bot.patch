 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/README.md b/README.md
index e292ac049d81ee85ee243b0632e101405803e46a..ca835f566d1c1747dbe4fde10b578bccf4a88f79 100644
--- a/README.md
+++ b/README.md
@@ -665,50 +665,66 @@ Async.await(promise) -- value -- for coroutines
 Async.await_all(promises) -- values[] -- for coroutines
 Async.promisify(coroutine) -- promise
 Async.create_promise(function(resolve)) -- promise -- resolve = function(value)
 Async.request(url, { method?, headers?, body? }?) -- promise, value = { status, headers, body }?
 Async.download(path, url, { method?, headers?, body? }?) -- promise, value = bool
 Async.read_file(path) -- promise, value = string
 Async.write_file(path, content) -- promise, value = bool
 Async.poll_server(address, port) -- promise, value = { max_message_size }?
 Async.message_server(address, port, data) -- you will not know if this succeeds, the other server will need to reply
 Async.sleep(duration) -- promise, value = nil
 ```
 
 ### Asyncified Net API
 
 Async alternatives to some Net API functions. Promises return nil if the user disconnects.
 
 ```lua
 Async.message_player(player_id, message, mug_texture_path?, mug_animation_path?) -- promise, value = number?
 Async.question_player(player_id, question, mug_texture_path?, mug_animation_path?) -- promise, value = number?
 Async.quiz_player(player_id, option_a?, option_b?, option_c?, mug_texture_path?, mug_animation_path?) -- promise, value = number?
 Async.prompt_player(player_id, character_limit?, default_text?) -- promise, value = string?
 Async.initiate_encounter(player_id, package_path, data?) -- promise, value = { player_id: string, health: number, score: number, time: number, ran: bool, emotion: number, turns: number, enemies: { id: String, health: number }[] } }
 Async.initiate_pvp(player_1_id, player_2_id, field_script_path?) -- promise, value = { player_id: string, health: number, score: number, time: number, ran: bool, emotion: number, turns: number, enemies: { id: String, health: number }[] } }
 ```
 
+### Bot Scenes
+
+Bots using `bot_base.lua` can define simple cut-scenes.  Each bot stores per player
+state in `bot_instance.player_states[player_id]` and chooses a scene from
+`config.SCENES` based on the current state (defaulting to `config.initial_state`).
+
+A scene is an array of actions executed sequentially with `SceneRunner.run`:
+
+- `say { text = "..." }` &ndash; shows a message and waits until the player dismisses it.
+- `move { direction = "north", distance = 1 }` &ndash; moves the bot and waits for arrival.
+- `wait { time = 1.0 }` &ndash; pauses for a period of time.
+- `set_state { key = "state", value = "next" }` &ndash; updates the player's stored state.
+
+Scenes can update the stored state to progress to another scene on the next
+interaction.
+
 ### Event Emitters
 
 ```lua
 local emitter = Net.EventEmitter.new()
 emitter:emit(event_name, ...)
 emitter:on(event_name, function(...))
 emitter:once(event_name, function(...))
 emitter:on_any(function(event_name, ...))
 emitter:on_any_once(function(event_name, ...))
 emitter:remove_listener(event_name, callback)
 emitter:remove_on_any_listener(callback)
 emitter:async_iter(event_name) -- iterator that returns promises, value = ...
 emitter:async_iter_all(event_name) -- iterator that returns promises, value = event_name, ...
 emitter:destroy() -- allows async iterators to complete
 ```
 
 ### Lua STD Changes
 
 `print` and `tostring` will display tables.
 
 `printerr` will output red text to stdout.
 
 ## Building the Project
 
 Windows requires for building lua [MSVC++](https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170#visual-studio-2015-2017-2019-and-2022)
diff --git a/scripts/bot_base.lua b/scripts/bot_base.lua
index 4f3e374a3d2264e476a5edc083af3d21c779560c..128596e2b642024ea77ef6b2fa4746449ad7533e 100644
--- a/scripts/bot_base.lua
+++ b/scripts/bot_base.lua
@@ -1,28 +1,29 @@
 -- scripts/bot_base.lua
 local Direction = require("scripts/libs/direction")
 local BotMovementHelper = require("scripts/bot_movement_helper") -- Assuming BotMovementHelper is loaded successfully
+local SceneRunner = require("scripts/scene_runner")
 
 local BotBase = {}
 BotBase.__index = BotBase -- For metatable-based object orientation (optional but good practice)
 
 local all_active_bots = {} -- Stores all active bot instances by their bot_id
 
 -- Parses an action string into a command table. (Same as before)
 local function parse_action_string(action_str)
     local move_cmd, move_dir, move_dist = action_str:match("^(move)%s+([%a]+)%s+([%d%.]+)$")
     if move_cmd then return { command = "move", direction_str = string.lower(move_dir), distance = tonumber(move_dist) } end
     local wait_cmd, wait_time = action_str:match("^(wait)%s+([%d%.]+)$")
     if wait_cmd then return { command = "wait", time = tonumber(wait_time) } end
     if string.lower(action_str) == "loop" then return { command = "loop" } end
     print("BOT_BASE WARNING: Could not parse action string: '" .. action_str .. "'")
     return nil
 end
 
 --- Creates a new bot instance.
 -- @param config table The specific configuration for this bot (ACTION_LIST, BOT_SETUP_CONFIG contents)
 function BotBase.new(config)
     local instance = setmetatable({}, BotBase)
 
     instance.config = config -- Store the provided config (includes dialogue, action list, etc.)
     
     local initial_pos_obj = Net.get_object_by_name(instance.config.area_id, instance.config.spawn_object_name)
@@ -39,143 +40,130 @@ function BotBase.new(config)
 
     if not bot_id_from_net then
         print("BOT_BASE ERROR: Failed to create bot entity for '" .. instance.config.bot_name .. "'.")
         return nil
     end
 
     instance.bot_object = BotMovementHelper.create_bot_object(
         bot_id_from_net, initial_pos_obj,
         { area_id = instance.config.area_id, mug_texture_path = instance.config.mug_texture_path,
           mug_animation_path = instance.config.mug_animation_path, speed = instance.config.speed,
           size = instance.config.bot_collision_size }
     )
 
     if not instance.bot_object then
          print("BOT_BASE ERROR: Failed to create bot_object state for '" .. instance.config.bot_name .. "'.")
          -- Potentially destroy the Net.created_bot if cleanup is needed
          return nil
     end
 
     -- Action processing state for this instance
     instance.current_action_index = 1
     instance.current_action_data = nil
     instance.is_processing_action = false
     instance.action_list_paused = false
     instance.interacting_player_id = nil
+    instance.player_states = {}
 
     all_active_bots[bot_id_from_net] = instance -- Register this bot instance
     print("BOT_BASE: Initialized bot '" .. instance.config.bot_name .. "' with ID: " .. instance.bot_object.id)
     
     -- Start its first action if not paused
     if not instance.action_list_paused then
         instance:process_next_action() -- Call as a method
     end
     return instance
 end
 
 --- Method to process the next action for a bot instance.
 function BotBase:process_next_action()
     if self.current_action_index > #self.config.ACTION_LIST then
         self.is_processing_action = false; self.current_action_data = nil; return
     end
     local action_string = self.config.ACTION_LIST[self.current_action_index]
     if not action_string then
         self.current_action_index = self.current_action_index + 1; self.is_processing_action = false; return
     end
 
     local parsed_action = parse_action_string(action_string)
     if not parsed_action then
         self.current_action_index = self.current_action_index + 1; self.is_processing_action = false; return
     end
 
     self.current_action_data = parsed_action
 
     if parsed_action.command == "move" then
         local destination = BotMovementHelper.calculate_action_destination(self.bot_object.current_tile_pos, parsed_action.direction_str, parsed_action.distance)
         if destination then
             self.bot_object.walk_target = destination; self.bot_object.walking = true; self.is_processing_action = true
         else
             print("BOT_BASE (" .. self.config.bot_name .. "): Move target for '" .. action_string .. "' is invalid/blocked. Skipping.")
             self.is_processing_action = false; self.current_action_data = nil
         end
         self.current_action_index = self.current_action_index + 1
     elseif parsed_action.command == "wait" then
         self.current_action_data.time_remaining = parsed_action.time; self.is_processing_action = true
         self.current_action_index = self.current_action_index + 1
     elseif parsed_action.command == "loop" then
         self.current_action_index = 1; self.is_processing_action = false; self.current_action_data = nil
     else
         self.current_action_index = self.current_action_index + 1; self.is_processing_action = false; self.current_action_data = nil
     end
 end
 
 --- Method to handle actor interaction for a bot instance.
 function BotBase:handle_interaction(event_player_id)
     if self.interacting_player_id ~= nil then
-        if self.interacting_player_id == event_player_id then return -- Redundant event
-        else
+        if self.interacting_player_id == event_player_id then return else
             Net.message_player(event_player_id, self.config.dialogue_busy, self.bot_object.mug_texture_path, self.bot_object.mug_animation_path)
             return
         end
     end
 
     self.interacting_player_id = event_player_id
     self.action_list_paused = true
-    print("BOT_BASE (" .. self.config.bot_name .. "): Interaction started with " .. event_player_id .. ". Pausing actions.")
 
-    Net.lock_player_input(self.interacting_player_id)
-    local bot_actual_pos = Net.get_bot_position(self.bot_object.id) or self.bot_object.current_tile_pos
-    local player_pos = Net.get_player_position(self.interacting_player_id)
-    if player_pos and bot_actual_pos then
-        Net.set_bot_direction(self.bot_object.id, Direction.from_points(bot_actual_pos, player_pos))
+    local state_table = self.player_states[event_player_id]
+    if not state_table then
+        state_table = { state = self.config.initial_state }
+        self.player_states[event_player_id] = state_table
     end
 
-    local self_instance = self -- Capture for the .and_then closure
-    Async.question_player(self.interacting_player_id,
-        self.config.dialogue_main_prompt,
-        self.bot_object.mug_texture_path,
-        self.bot_object.mug_animation_path
-    )
-    .and_then(function(response_code)
-        local player_who_finished = self_instance.interacting_player_id -- Should be the same as self.interacting_player_id
-
-        local pcall_ok, err_msg = pcall(function()
-            if response_code == nil then return end
-            local response_category = BotMovementHelper.process_interaction_outcome(self_instance.bot_object, response_code)
-            local message_to_send
-            if response_category == "positive" then message_to_send = self_instance.config.dialogue_response_positive
-            else message_to_send = self_instance.config.dialogue_response_negative end
-            Net.message_player(player_who_finished, message_to_send, self_instance.bot_object.mug_texture_path, self_instance.bot_object.mug_animation_path)
-        end)
-
-        Net.unlock_player_input(player_who_finished)
-        if self_instance.interacting_player_id == player_who_finished then
-            self_instance.interacting_player_id = nil
-        end
-        self_instance.action_list_paused = false
-        print("BOT_BASE (" .. self_instance.config.bot_name .. "): Interaction ended with " .. player_who_finished .. ". Resuming actions.")
-        if not pcall_ok then print("BOT_BASE ERROR (" .. self_instance.config.bot_name .. "): Dialogue processing: " .. tostring(err_msg)) end
+    local scene_key = state_table.state or self.config.initial_state
+    local scene = nil
+    if self.config.SCENES then scene = self.config.SCENES[scene_key] end
+
+    if not scene then
+        self.interacting_player_id = nil
+        self.action_list_paused = false
+        return
+    end
+
+    SceneRunner.run(self, event_player_id, scene)
+    .and_then(function()
+        self.interacting_player_id = nil
+        self.action_list_paused = false
     end)
 end
 
 --- Method to update a bot instance on tick.
 function BotBase:update_tick(dt)
     if self.action_list_paused then return end
 
     if self.is_processing_action then
         if self.bot_object.walking then
             BotMovementHelper.update_movement_on_tick(self.bot_object, dt, Net)
             if not self.bot_object.walking then self.is_processing_action = false; self.current_action_data = nil end
         elseif self.current_action_data and self.current_action_data.command == "wait" then
             self.current_action_data.time_remaining = self.current_action_data.time_remaining - dt
             if self.current_action_data.time_remaining <= 0 then self.is_processing_action = false; self.current_action_data = nil end
         end
     end
 
     if not self.is_processing_action then
         self:process_next_action()
     end
 end
 
 
 -- Global Event Handlers (These will dispatch to the correct bot instance)
 Net:on("actor_interaction", function(event)
diff --git a/scripts/bot_movement_helper.lua b/scripts/bot_movement_helper.lua
index 296a34254275cff5352fcba90d648e3a403dc9ff..bc376249aa7a3d55409c5bfe360cb39f7ab4a081 100644
--- a/scripts/bot_movement_helper.lua
+++ b/scripts/bot_movement_helper.lua
@@ -111,26 +111,52 @@ function BotMovementHelper.process_interaction_outcome(bot_object, response_code
         return "positive"
     else
         return "negative"
     end
     -- No movement logic here; action list controls movement.
 end
 
 function BotMovementHelper.update_movement_on_tick(bot_object, dt, Net)
     if not bot_object.walking or not bot_object.walk_target then return end
     local current_pos_actual = Net.get_bot_position(bot_object.id)
     if not current_pos_actual then
         bot_object.walking = false
         return
     end
     local nx, ny, nz, arrived = _step_towards_target(current_pos_actual, bot_object.walk_target, bot_object.speed, dt)
     if arrived then
         bot_object.walking = false
         Net.move_bot(bot_object.id, bot_object.walk_target.x, bot_object.walk_target.y, bot_object.walk_target.z)
         bot_object.current_tile_pos = {x=bot_object.walk_target.x, y=bot_object.walk_target.y, z=bot_object.walk_target.z}
         bot_object.walk_target = nil
     else
         Net.move_bot(bot_object.id, nx, ny, nz)
     end
 end
 
-return BotMovementHelper
\ No newline at end of file
+function BotMovementHelper.move_async(bot_object, direction_str, distance)
+    local destination = BotMovementHelper.calculate_action_destination(
+        bot_object.current_tile_pos,
+        direction_str,
+        distance
+    )
+    if not destination then
+        return Async.create_promise(function(resolve) resolve(false) end)
+    end
+
+    bot_object.walk_target = destination
+    bot_object.walking = true
+
+    return Async.create_promise(function(resolve)
+        local function on_tick(event)
+            BotMovementHelper.update_movement_on_tick(bot_object, event.delta_time, Net)
+            if not bot_object.walking then
+                Net:remove_listener("tick", on_tick)
+                resolve(true)
+            end
+        end
+
+        Net:on("tick", on_tick)
+    end)
+end
+
+return BotMovementHelper
diff --git a/scripts/configs/another_bot_config.lua b/scripts/configs/another_bot_config.lua
index 474ac23228bba96e736fb6642497f7fad1db61e7..58994c77d800451ecabecbfed4f026960c9ac41e 100644
--- a/scripts/configs/another_bot_config.lua
+++ b/scripts/configs/another_bot_config.lua
@@ -1,31 +1,44 @@
 -- scripts/configs/another_bot_config.lua
 local config = {
     -- Identity & Appearance
     area_id = "default",
     spawn_object_name = "Bot Spawn 2", -- For the second bot
     bot_name = "GuardBot_Alpha",
     texture_path = "/server/assets/prog.png",
     animation_path = "/server/assets/prog.animation",
     mug_texture_path = "resources/ow/prog/prog_mug.png",
     mug_animation_path = "resources/ow/prog/prog_mug.animation",
 
     -- Behavior
     speed = 1.5, -- Slightly faster
     bot_collision_size = 0.5,
 
     -- Dialogue
     dialogue_main_prompt = "State your purpose. I am GuardBot Alpha.",
     dialogue_response_positive = "Understood. Proceed.",
     dialogue_response_negative = "Suspicious. I am watching you.",
     dialogue_busy = "Standby. Attending to another individual.",
 
+    initial_state = "first_meeting",
+    SCENES = {
+        first_meeting = {
+            { say = { text = "Halt!" } },
+            { move = { direction = "north", distance = 1 } },
+            { set_state = { key = "state", value = "second_meeting" } }
+        },
+        second_meeting = {
+            { say = { text = "Proceed." } },
+            { move = { direction = "south", distance = 1 } }
+        }
+    },
+
     -- Action Sequence
     ACTION_LIST = {
         "move north 4",
         "wait 5.0",
         "move south 4",
         "wait 5.0",
         "loop"
     }
 }
-return config
\ No newline at end of file
+return config
diff --git a/scripts/configs/polite_bot_config.lua b/scripts/configs/polite_bot_config.lua
index ba8d67856a8cba6ec8536399574ce60b1e4d3a45..135969c47e90ee9d7932b6c629a3e8f820007a7c 100644
--- a/scripts/configs/polite_bot_config.lua
+++ b/scripts/configs/polite_bot_config.lua
@@ -1,36 +1,50 @@
 -- scripts/configs/polite_bot_config.lua
 local config = {
     -- Identity & Appearance
     area_id = "default",
     spawn_object_name = "Bot Spawn", -- For the first bot
     bot_name = "PoliteActionBot_1",
     texture_path = "/server/assets/prog.png",
     animation_path = "/server/assets/prog.animation",
     mug_texture_path = "resources/ow/prog/prog_mug.png",
     mug_animation_path = "resources/ow/prog/prog_mug.animation",
     
     -- Behavior
     speed = 1,
     bot_collision_size = 0.5,
     
     -- Dialogue
     dialogue_main_prompt = "Greetings! I am the first Polite Bot. How can I help you on my patrol?",
     dialogue_response_positive = "Excellent!",
     dialogue_response_negative = "Ah, I see.",
     dialogue_busy = "One moment please, I'm assisting someone else.",
 
+    initial_state = "first_meeting",
+    SCENES = {
+        first_meeting = {
+            { say = { text = "Hello there!" } },
+            { move = { direction = "south", distance = 1 } },
+            { set_state = { key = "state", value = "second_meeting" } }
+        },
+        second_meeting = {
+            { say = { text = "Good to see you again!" } },
+            { move = { direction = "north", distance = 1 } }
+        }
+    },
+
     -- Action Sequence
     ACTION_LIST = {
     "move south 2",
     "wait 2.0",
     "move east 2",
     "move north 1",
     "move east 1",
     "wait 1.5",
     "move north 2",
     "move west 3",
     "move south 1",
     "loop"
 }
 }
-return config
\ No newline at end of file
+return config
+
diff --git a/scripts/scene_runner.lua b/scripts/scene_runner.lua
new file mode 100644
index 0000000000000000000000000000000000000000..fb36abf79aa75eb4043d4482feef553522f33455
--- /dev/null
+++ b/scripts/scene_runner.lua
@@ -0,0 +1,33 @@
+local BotMovementHelper = require("scripts/bot_movement_helper")
+
+local SceneRunner = {}
+
+function SceneRunner.run(bot_instance, player_id, scene)
+  if not scene then
+    return Async.create_promise(function(resolve) resolve() end)
+  end
+
+  if bot_instance.player_states[player_id] == nil then
+    bot_instance.player_states[player_id] = {}
+  end
+
+  return Async.promisify(coroutine.create(function()
+    for _, action in ipairs(scene) do
+      if action.say then
+        Async.await(Async.message_player(player_id, action.say.text,
+          bot_instance.bot_object.mug_texture_path,
+          bot_instance.bot_object.mug_animation_path))
+      elseif action.move then
+        Async.await(BotMovementHelper.move_async(bot_instance.bot_object,
+          action.move.direction, action.move.distance))
+      elseif action.wait then
+        Async.await(Async.sleep(action.wait.time or action.wait))
+      elseif action.set_state then
+        bot_instance.player_states[player_id][action.set_state.key] = action.set_state.value
+      end
+    end
+  end))
+end
+
+return SceneRunner
+
 
EOF
)